<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>c语言if语句的逆向 | 天蝎软件 | scorcsoft</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">c语言if语句的逆向</h1><a id="logo" href="/.">天蝎软件 | scorcsoft</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">c语言if语句的逆向</h1><div class="post-meta">Dec 25, 2018</div><div class="post-content"><h2 id="0x01-内存图"><a href="#0x01-内存图" class="headerlink" title="0x01 内存图"></a>0x01 内存图</h2><p>程序在运行时是加载到内存里面执行的(内存指的是内存条，也就是程序运行时它就被从硬盘里复制了一份到内存条里)。在一块内存中分为5个区：</p>
<p><img src="/2018/12/25/c语言if语句的逆向/1.jpg" alt=""></p>
<p>栈(stack)在中文里叫做”堆栈”，而堆(heap)就叫”堆”。这个我不明白是为什么。</p>
<h2 id="0x02-全局变量"><a href="#0x02-全局变量" class="headerlink" title="0x02 全局变量"></a>0x02 全局变量</h2><p>全局变量的地址在编译的时候就已经确定了。</p>
<p>全局变量可以被所有的函数读写。</p>
<p>全局变量会一直占用内存，直到整个线程结束。</p>
<p>全局变量在汇编里的特征是: 在读写全局变量时，地址是一个固定的十六进制值，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR DS:[0x11111111]</span><br></pre></td></tr></table></figure>
<h2 id="0x03-局部变量"><a href="#0x03-局部变量" class="headerlink" title="0x03 局部变量"></a>0x03 局部变量</h2><p>局部变量没有固定的地址</p>
<p>局部变量只有被创建(局部变量所在的函数被调用)时才会分配内存</p>
<p>局部变量储存在堆栈里面</p>
<p>局部变量所在的函数运行完毕后就被丢弃了，虽然局部变量所储存的值仍然存放在堆栈里，但是它已经是一个垃圾值了。下一次调用其它函数时可能会被覆盖掉。</p>
<p>局部变量的特征是: 在读写局部变量时，地址是通过栈底指针或栈顶指针加减偏移量来找到地址的，例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR DS:[EBP-4]</span><br></pre></td></tr></table></figure>
<h2 id="0x04-参数个数"><a href="#0x04-参数个数" class="headerlink" title="0x04 参数个数"></a>0x04 参数个数</h2><p>函数调用的第一步就是参数压栈，所以在判断函数的参数个数的时候，第一步先看在函数调用时有多少个push，然后再通过堆栈平衡的代码来验证。</p>
<p>如果是外平栈，就看平衡堆栈时把堆栈指针回退了几个单位。</p>
<p>如果是内平栈，就看平衡堆栈时RET的值是多少。</p>
<p>在windows中堆栈的地址顺序是从大到小的，所以堆栈指针回退就应该是地址变大(加)，提升就应该是地址变小(减)。</p>
<p>通过这两个步骤在一般情况下就可以知道函数有几个参数了。假如有两个push，平衡堆栈的代码也正好是add esp,0x8，那么参数的个数就应该是两个。假如有3个push，平衡堆栈的代码是add esp,0xC，那么参数的个数就应该是3个。</p>
<h2 id="0x05-if语句"><a href="#0x05-if语句" class="headerlink" title="0x05 if语句"></a>0x05 if语句</h2><p>如果有几行影响标志寄存器的指令，然后下面紧接着就是一个JCC指令，那这就很可能是一个if语句。</p>
<p>这是一个c语言的if语句的正向代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)&#123;</span><br><span class="line">        MAX = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fun(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个函数fun，有两个int类型的形参a和b。然后函数里面有一个判断，如果参数a大于参数b，那么就把a的值赋给全局变量MAX。</p>
<p>在VC6里编译运行，然后右键查看它的汇编代码，调用fun函数的汇编代码:</p>
<p><img src="/2018/12/25/c语言if语句的逆向/2.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00401078   push        3</span><br><span class="line">0040107A   push        5</span><br><span class="line">0040107C   call        @ILT+0(_fun) (00401005)</span><br><span class="line">00401081   add         esp,8</span><br></pre></td></tr></table></figure>
<p>首先就是两个push，把fun()函数的两个参数压栈，然后就是call指令开始调用函数。call指令下面的add指令是为了实现堆栈平衡，上面有2个push，平衡堆栈的指令正好是把堆栈指针回退8个字节(2个单位)，由此可以知道fun()函数的参数个数是2个。</p>
<p>在call指令那里f11单步步入，进入fun()函数:</p>
<p><img src="/2018/12/25/c语言if语句的逆向/3.jpg" alt=""></p>
<p>首先是堆栈操作(0x401020到0x401036)，提升堆栈，填充缓冲区。对堆栈的操作是在堆栈图的时候学习的，就不用多说了。</p>
<p>再下面就是if语句了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401038   mov         eax,dword ptr [ebp+8]</span><br><span class="line">0040103B   cmp         eax,dword ptr [ebp+0Ch]</span><br><span class="line">0040103E   jle         fun+29h (00401049)</span><br></pre></td></tr></table></figure>
<p>首先是MOV指令把ebp+0x8的地址里的值放到eax寄存器，然后cmp指令把 ebp+0xC的地址的值 与 eax 的值进行比较，紧接着就是一个JCC指令。cmp指令会影响标志寄存器，而JCC指令就是根据标志寄存器来决定是否跳转的。</p>
<p>c语言的if语句和汇编里的jcc指令的逻辑是完全相反的，例如c语言里if判断的是大于，那么在汇编里jcc指令就是jle，jle的意思是小于等于则跳转。为什么逻辑是完全相反的其实这个很好理解，因为正向代码里if的条件如果成立，就会执行if下面的代码。</p>
<p>cmp指令是判断if条件是否成立，而jcc指令是判断是否执行if下的代码。</p>
<p>if判断的是大于，那么jcc指令就是jle，小于等于时跳转，如果if条件的大于是成立的，那么jle指令就不会跳转，汇编执行jle执行下面的那一行代码(在正向代码就相当于if成立，就执行if括号里的代码块)。如果if条件的大于是不成立的，只要大于不成立，那么小于或等于就必定是成立的，那么jle就会跳转，jle就跳走啦，跳去执行其他地方的代码了(在正向代码里就相当于if条件不成立，那么if下面的代码就不能执行了，转去执行if的花括号之外的代码了)。就像在这个例子里，它jle跳到0x401049了，0x401049的代码就是if的花括号之外的代码，是xor eax,eax;把eax清零了。也就是c语言的return 0;这一行代码</p>
<p>在正向代码里，如果a大于b，就把a的值赋给全局变量MAX，来看汇编里是怎样实现的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00401040   mov         ecx,dword ptr [ebp+8]</span><br><span class="line">00401043   mov         dword ptr [_MAX (00427c50)],ecx</span><br></pre></td></tr></table></figure>
<p>首先把ebp+8的地址的值放到ecx寄存器，然后把ecx寄存器的值放到0x427c50。上面也说了全局变量的主要特征之一就是它的地址是固定的一个十六进制值。</p>
<h2 id="0x06-ebp-和ebp"><a href="#0x06-ebp-和ebp" class="headerlink" title="0x06 ebp+和ebp-"></a>0x06 ebp+和ebp-</h2><p>ebp+是参数，ebp-是局部变量。</p>
<p><img src="/2018/12/25/c语言if语句的逆向/5.jpg" alt=""></p>
<p>在调用函数的时候，第一步就是把参数压入堆栈，c语言是从右到左的顺序，所以fun(5,3);的压栈顺序是push 3然后push 5;。</p>
<p>参数入栈以后就执行call指令，call执行调用函数时会把返回地址压入堆栈，现在堆栈里就有3个数据了，这三个数据从栈顶到栈底的顺序分别是函数返回地址、函数左边第一个参数、函数左边第二个参数。</p>
<p>call指令返回地址入栈以后就真正进入被调用的函数里面了，进入函数以后就开始堆栈操作，第一行就是push ebp，把当前栈底地址压入堆栈。然后mov ebp,esp，把当前栈顶地址作为栈底地址完成堆栈提升。</p>
<p>push ebp后，堆栈里就有4个数据了，从栈顶到栈底的顺序分别是函数调用前的栈底地址、函数返回地址、函数左边第一个参数、函数左边第二个参数。</p>
<p>然后mov ebp,esp把栈顶作为栈底，在windows中，堆栈地址是按照从大到小的顺序，那么ebp + 4就是栈底往后退4个字节，就是函数返回地址，ebp + 8就是最后一个压入堆栈的参数(左边第一个)，ebp + c就是倒数第二个压入堆栈的参数(左边第二个)。</p>
<p>所以ebp+偏移就是传入函数的参数了，ebp+0x4是函数调用前的栈底地址。</p>
<p>ebp+0x8就是最后一个压入堆栈的参数，也就是函数左边第一个参数</p>
<p>ebp+0xC就是倒数第二个压入堆栈的参数，也就是函数左边第二个参数</p>
<p>ebp+0x10就是倒数第三个压入堆栈的参数，也就是函数左边第三个参数</p>
<p>ebp+0x14就是倒数第四个压入堆栈的参数，也就函数左边第四个参数</p>
<p>以此类推，这个很好理解。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/12/27/C语言if和else的逆向分析/">C语言if和else的逆向分析</a><a class="next" href="/2018/12/04/jmp和call/">jmp和call</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'Scorcsoft',
  repo: 'scorcsoft.github.io',
  oauth: {
    client_id: '2548ca2e4fc61743abea',
    client_secret: '11dfce9cc6fad8dce061c8eb69760afa9c811b5c',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://scorcsfot.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/27/C语言if和else的逆向分析/">C语言if和else的逆向分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/25/c语言if语句的逆向/">c语言if语句的逆向</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/04/jmp和call/">jmp和call</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/02/标志寄存器/">标志寄存器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/01/pushad与popad/">pushad与popad</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/01/逆向工程学习-堆栈/">逆向工程学习:堆栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/2-3/">2+3=?</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/11/我回来啦/">我回来啦~</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="https://billts.site/" title="码农BTS" target="_blank">码农BTS</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">天蝎软件 | scorcsoft.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
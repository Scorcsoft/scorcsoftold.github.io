<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>逆向工程学习:堆栈 | 天蝎软件 | scorcsoft</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">逆向工程学习:堆栈</h1><a id="logo" href="/.">天蝎软件 | scorcsoft</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">逆向工程学习:堆栈</h1><div class="post-meta">Dec 1, 2018</div><div class="post-content"><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>我最近在学习逆向，所以写写博客一来是增加文章数量，二来是加深记忆。我现在已学到堆栈，所以写这篇博文，记录一下自己学到的东西。<a id="more"></a></p>
<h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>堆栈的优点是可以临时存储大量的数据，而且便于查找。这些数据储存在内存中，而不是储存在CPU里的寄存器中。实现一个堆栈结构需要使用两个寄存器，一个用来储存栈底地址，一个用来储存栈顶地址(我用ebp做栈底寄存器，用esp做栈顶寄存器，在很多地方都是用esp寄存器做堆栈指针的嘛，esp就是extended stack pointer的缩写，翻译过来就是栈指针的意思)。</p>
<p>数据压栈时，栈底指针不动，而栈顶指针永远指向栈顶的位置。在windows中，内存地址是从大到小的顺序排列的，那么栈底的内存编号必是大于栈顶的内存编号的。所以压栈时栈顶指针是减去一个单位，而出栈时栈顶指针是加上一个单位。通过计算栈顶到栈底的偏移量也可以计算出堆栈中储存了多少数据，这也是堆栈的另一个优点。</p>
<p>如果要取出堆栈中间某一个位置的数据，只需要使用栈顶或者栈底的位置加上偏移量就可以了。</p>
<h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>我这里用汇编实现了一个堆栈，并且将1、2、3、4压入堆栈，栈底地址为0x12FFFC。</p>
<p>Ps: 我是直接用od打开一个exe文件，然后修改执行汇编代码的</p>
<p>首先就是把内存地址放进寄存器里面，栈底地址是0x12FFFC，那么就是0x12FFFC储存进ebp寄存器里面。现在还是一个空堆栈，所以栈顶的位置和栈底是一样的，也是12xFFFC。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ebp,0x12FFFC</span><br><span class="line">mov esp,0x12FFFC</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/01/逆向工程学习-堆栈/1.jpg" alt=""></p>
<p>按下F8单步执行后，esp寄存器和ebp寄存器的值就都变成栈底地址0x12FFFC了。</p>
<p>堆栈已经创建好了，接下来就是压栈。我使用先压栈，后移动指针的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[esp],0x1</span><br></pre></td></tr></table></figure>
<p>执行后，内存0x12FFFC里面的值就变成1了。</p>
<p>Ps: 内存的最小单位是字节，1个字节等于8位，也就是8个0或者1。</p>
<p>除了DWORD，还有两种数据宽度：byte和word。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BYTE: 1字节 8位</span><br><span class="line">WORD: 2字节 16位</span><br><span class="line">DWORD: 4字节 32位</span><br></pre></td></tr></table></figure>
<p>压栈以后紧接着就要移动堆栈指针，我刚才使用的数据宽度是DWORD，DWORD占用4个字节，那么堆栈指针就需要减去4个字节的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub esp,4</span><br></pre></td></tr></table></figure>
<p>执行以后，esp寄存器里面的值就是0x12FFFC减去4的值，也就是0x12FFF8。</p>
<p>按照这个步骤继续把剩余的数字压入堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[esp],0x2</span><br><span class="line">sub esp,4</span><br><span class="line">mov dword ptr ds:[esp],0x3</span><br><span class="line">sub esp,4</span><br><span class="line">mov dword ptr ds:[esp],0x4</span><br><span class="line">sub esp,4</span><br></pre></td></tr></table></figure>
<p>F8单步执行以上几行汇编代码：</p>
<p><img src="/2018/12/01/逆向工程学习-堆栈/2.jpg" alt=""></p>
<p>执行完以后可以看到栈底指针ebp指向0x12FFFC，栈顶指针esp指向0x12FFF0。</p>
<p>内存0x12FFF0里面的值为4</p>
<p>内存0x12FFF4里面的值为3</p>
<p>内存0x12FFF8里面的值为2</p>
<p>内存0x12FFFC里面的值为1</p>
<p>完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ebp,0x12FFFC</span><br><span class="line">mov esp,0x12FFFC</span><br><span class="line"></span><br><span class="line">mov dword ptr ds:[esp],0x1</span><br><span class="line">sub esp,0x4</span><br><span class="line">mov dword ptr ds:[esp],0x2</span><br><span class="line">sub esp,0x4</span><br><span class="line">mov dword ptr ds:[esp],0x3</span><br><span class="line">sub esp,0x4</span><br><span class="line">mov dword ptr ds:[esp],0x4</span><br><span class="line">sub esp,0x4</span><br></pre></td></tr></table></figure>
<p>当最后一个值压入堆栈以后，堆栈指针还是要移动，必须保证堆栈指针永远指向栈顶的位置。</p>
<h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><p>从堆栈中取值时，只需要用栈底或栈顶地址加上偏移量就可以了。例如把堆栈中第3个元素放入eax寄存器里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov eax,dword ptr ds:[ebp-8]</span><br></pre></td></tr></table></figure>
<p>Ps: 堆栈是先进后出的结构，栈底的元素就是第一个元素，而栈顶的元素就是最后一个元素。第3个元素到第1个元素的距离是2个间隔，每一个间隔的数据宽度是4字节，那么第3个元素距离栈底的偏移量就是8个字节，所以栈底地址减去8就是第三个元素的地址，所以使用栈底指针ebp-8就可以找到第三个元素:</p>
<p><img src="/2018/12/01/逆向工程学习-堆栈/3.jpg" alt=""></p>
<p>使用栈顶指针取值也是同理，堆栈中一共有4个元素，第3个元素到栈顶的距离就是1，每一个间隔的数据宽度是4字节，那么栈顶的位置加上4字节的偏移量就是第3个元素的地址，这次把值放入ecx寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ecx,dword ptr ds:[esp+4]</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/01/逆向工程学习-堆栈/4.jpg" alt=""></p>
<h2 id="0x5"><a href="#0x5" class="headerlink" title="0x5"></a>0x5</h2><p>除了上面的手动压栈以外，可以使用更方便的push指令，push指令的作用就是把数据压入堆栈，并且自动移动栈顶指针。</p>
<p>操作系统默认是用ebp寄存器来存放栈底地址，esp寄存器来存放栈顶地址。为了便于观察，我先把现在这个程序的堆栈清空，然后把栈顶指针和栈底指针都放到0x12FFFC:</p>
<p><img src="/2018/12/01/逆向工程学习-堆栈/6.jpg" alt=""></p>
<p>现在esp和ebp都是指向0x12FFFC的，并且0x12FFFC到0x12FFCC这段内存里储存的值都是0。</p>
<p>使用push指令压几个数据到堆栈里:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">push 0x1</span><br><span class="line">push 0x2</span><br><span class="line">push 0x3</span><br><span class="line">push 0x4</span><br><span class="line">push 0x5</span><br><span class="line">push 0x6</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/01/逆向工程学习-堆栈/7.jpg" alt=""></p>
<p>按F8单步执行这6行push以后，可以看到堆栈指针esp已经指向的0x12FFE4，栈底指针还是原来的位置，而1、2、3、4、5、6这6个数字已经被压入堆栈。</p>
<p>push一个立即数的时候，它的数据宽度是32位，也就是DWORD。</p>
<p>除了立即数，也可以push一个寄存器，或者push一个内存地址。</p>
<p>push寄存器或者内存地址的时候，可以push一个16位或者32位的寄存器或者内存，但是<font style="color:red">不能push一个8位的寄存器或者内存</font>。</p>
<p>这么写是可以的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push eax</span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">push dword ptr ds:[内存地址]</span><br><span class="line">push word ptr ds:[内存地址]</span><br></pre></td></tr></table></figure>
<p>eax是32位的寄存器，ax是16位的寄存器，dword的宽度是32位，word的宽度是16位。</p>
<p>但是这么写是<font style="color:red">错误的</font>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push al</span><br><span class="line">push byte ptr ds:[内存地址]</span><br></pre></td></tr></table></figure>
<p>al是一个8位的寄存器，byte的数据宽度是8位。</p>
<h2 id="0x6"><a href="#0x6" class="headerlink" title="0x6"></a>0x6</h2><p>出栈</p>
<p>出栈和通过偏移量取值是不一样的</p>
<p>通过偏移量取值是读取出堆栈中间某一个位置的值，取值时堆栈指针是不动的。</p>
<p>而出栈是把数据弹出堆栈，堆栈指针是要移动的。弹出一个，堆栈指针就要回退一个，把内存让出来。</p>
<p>pop指令可以很方便的弹出数据。</p>
<p>为了便于观察我先清空eax、ecx、edx和ebx这四个寄存器:</p>
<p><img src="/2018/12/01/逆向工程学习-堆栈/8.jpg" alt=""></p>
<p>然后使用pop指令把堆栈中后4个值弹出到这四个寄存器里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop eax</span><br><span class="line">pop ecx</span><br><span class="line">pop edx</span><br><span class="line">pop ebx</span><br></pre></td></tr></table></figure>
<p>现在堆栈指针esp指向的位置是0x12FFE4。而且这4个寄存器里的值都是0，F8单步执行以上4行代码：</p>
<p><img src="/2018/12/01/逆向工程学习-堆栈/9.jpg" alt=""></p>
<p>eax里面的值已经变成了6，ecx里面的值已经变成了5，edx里面的值已经变成了4，ebx里面的值已经变成了3。而堆栈指针esp已经自动回退到了0x12FFF4。</p>
<p>pop和push一样，可以pop到一个32位或者16位的寄存器或者内存，但是<font style="color:red">不能pop到一个8位的寄存器或内存</font></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/12/01/pushad与popad/">pushad与popad</a><a class="next" href="/2018/11/26/2-3/">2+3=?</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'Scorcsoft',
  repo: 'scorcsoft.github.io',
  oauth: {
    client_id: '2548ca2e4fc61743abea',
    client_secret: '11dfce9cc6fad8dce061c8eb69760afa9c811b5c',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://scorcsfot.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/02/标志寄存器/">标志寄存器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/01/pushad与popad/">pushad与popad</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/01/逆向工程学习-堆栈/">逆向工程学习:堆栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/26/2-3/">2+3=?</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/11/我回来啦/">我回来啦~</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="https://billts.site/" title="码农BTS" target="_blank">码农BTS</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">天蝎软件 | scorcsoft.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>